/**
 * Code snippets generator for module polyfills
 *
 * This module generates ESM wrapper code that enables using CommonJS modules
 * (Node.js builtins and CJS packages) in an ESM context within Electron's
 * renderer process.
 *
 * **The Problem:**
 * Vite uses ESM by default, but Electron's renderer process with nodeIntegration
 * needs require() for Node.js builtins and native modules. These wrappers bridge
 * the gap by:
 * 1. Using require() internally (which works in Electron)
 * 2. Exposing ESM exports externally (which works with Vite)
 *
 * **Key Technique:**
 * We use `const avoid_parse_require = require` to prevent bundlers from
 * statically analyzing and transforming the require() call. This ensures
 * the require() remains intact and is executed at runtime in Electron.
 */

import { createRequire } from "node:module";
import { getMainOnlyApis } from "./constants.js";

/**
 * Create a require function for this ESM module
 *
 * Since this is an ESM module, we need to create our own require function
 * to introspect CJS module exports.
 */
const require = createRequire(import.meta.url);

/**
 * Generate ESM export statements from a list of export names
 *
 * Creates valid ESM export syntax for each provided export name,
 * filtering out invalid identifiers and special exports.
 *
 * **Filtered exports:**
 * - 'default': Handled separately
 * - '__esModule': Internal flag, not a real export
 * - Invalid JS identifiers: Names that can't be used as variable names
 *
 * @param exportNames - Array of export names to generate
 * @returns Generated ESM export code
 *
 * @example
 * generateEsmExports(['readFile', 'writeFile', 'promises'])
 * // Returns:
 * // export default _M_.default || _M_;
 * // export const readFile = _M_.readFile;
 * // export const writeFile = _M_.writeFile;
 * // export const promises = _M_.promises;
 */
function generateEsmExports(exportNames: string[]): string {
  // Filter to only valid JavaScript identifiers
  // This prevents syntax errors in the generated code
  const validExports = exportNames.filter(
    (name) =>
      name !== "default" &&
      name !== "__esModule" &&
      /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name) // Valid JS identifier pattern
  );

  // If no valid exports, just export default
  if (validExports.length === 0) {
    return "export default _M_;";
  }

  // Generate named exports
  const namedExports = validExports
    .map((name) => `export const ${name} = _M_.${name};`)
    .join("\n");

  // Default export handles both: modules with default export and CJS modules
  // _M_.default || _M_ ensures compatibility with both styles
  return `export default _M_.default || _M_;\n${namedExports}`;
}

/**
 * Get all export names from a module using require
 *
 * Dynamically loads the module and returns all its enumerable property names.
 * This is used to generate accurate ESM wrappers with all exports.
 *
 * @param moduleName - Name of the module to inspect
 * @returns Array of export names, or empty array if module can't be loaded
 *
 * @example
 * getModuleExportNames('fs')
 * // Returns: ['readFile', 'writeFile', 'readdir', 'promises', ...]
 */
function getModuleExportNames(moduleName: string): string[] {
  try {
    const mod = require(moduleName);
    return Object.getOwnPropertyNames(mod);
  } catch {
    // Module might not be installed or might fail to load
    // Return empty array to generate a minimal wrapper
    return [];
  }
}

/**
 * Generate the electron polyfill code for the renderer process
 *
 * This generates a comprehensive wrapper for the 'electron' module that:
 *
 * 1. **Gracefully handles missing nodeIntegration**: Shows a helpful error
 *    message if require() is not available (nodeIntegration disabled)
 *
 * 2. **Handles Web Workers**: ipcRenderer doesn't work in Web Workers, so
 *    we provide a proxy that throws helpful errors
 *
 * 3. **Exports all Electron APIs**: Both renderer-available and main-only
 *    APIs are exported (main-only will be undefined in renderer)
 *
 * @returns Generated electron wrapper code
 *
 * @example
 * // Generated code structure:
 * // const electron = require("electron") or fallback
 * // export { electron as default }
 * // export const clipboard = electron.clipboard
 * // export const ipcRenderer = _ipcRenderer (proxied in workers)
 * // ... etc
 */
export function generateElectronSnippet(): string {
  const mainOnlyApis = getMainOnlyApis();

  return `
/**
 * Electron module wrapper for Vite compatibility
 * Generated by plugin-vite-electron-renderer
 */

// Load electron module with fallback for missing nodeIntegration
const electron = typeof require !== 'undefined'
  ? (function requireElectron() {
    // Use variable to prevent bundler from parsing require()
    const avoid_parse_require = require;
    return avoid_parse_require("electron");
  }())
  : (function nodeIntegrationWarn() {
    // Provide helpful error when nodeIntegration is disabled
    console.error(\`If you need to use "electron" in the Renderer process, make sure that "nodeIntegration" is enabled in the Main process.\`);
    return {};
  }());

/**
 * ipcRenderer proxy for Web Worker compatibility
 * 
 * Web Workers don't have access to ipcRenderer, so we provide a proxy
 * that throws helpful errors instead of cryptic undefined errors.
 * 
 * @see https://github.com/electron-vite/vite-plugin-electron/issues/69
 */
let _ipcRenderer;
if (typeof document === 'undefined') {
  // We're in a Web Worker context
  _ipcRenderer = {};
  const keys = [
    // Method APIs
    'invoke', 'postMessage', 'send', 'sendSync', 'sendTo', 'sendToHost',
    // EventEmitter APIs
    'addListener', 'emit', 'eventNames', 'getMaxListeners', 'listenerCount',
    'listeners', 'off', 'on', 'once', 'prependListener', 'prependOnceListener',
    'rawListeners', 'removeAllListeners', 'removeListener', 'setMaxListeners',
  ];
  for (const key of keys) {
    _ipcRenderer[key] = () => {
      throw new Error(
        'ipcRenderer doesn\\'t work in a Web Worker.\\n' +
        'You can see https://github.com/electron-vite/vite-plugin-electron/issues/69'
      );
    };
  }
} else {
  // Normal renderer context - use real ipcRenderer
  _ipcRenderer = electron.ipcRenderer;
}

// Default export for: import electron from 'electron'
export { electron as default };

// Renderer-available APIs (work in renderer with contextIsolation)
export const clipboard = electron.clipboard;
export const contextBridge = electron.contextBridge;
export const crashReporter = electron.crashReporter;
export const ipcRenderer = _ipcRenderer;
export const nativeImage = electron.nativeImage;
export const shell = electron.shell;
export const webFrame = electron.webFrame;
export const deprecate = electron.deprecate;

// Main-only APIs (will be undefined in renderer, but exported for type compatibility)
// These require IPC to access from renderer process
${mainOnlyApis
  .map((name) => `export const ${name} = electron.${name};`)
  .join("\n")}
`.trim();
}

/**
 * Generate ESM wrapper for any module (Node.js builtins or CJS packages)
 *
 * This is the core wrapper generation function. It creates an ESM module that:
 * 1. Uses require() to load the actual module at runtime
 * 2. Re-exports all the module's exports as ESM exports
 *
 * **The avoid_parse_require trick:**
 * We assign require to a variable before using it to prevent bundlers
 * (Vite, webpack, etc.) from statically analyzing and transforming the
 * require() call. This is essential for the wrapper to work in Electron.
 *
 * @param moduleName - Name of the module to wrap (e.g., 'fs', 'path')
 * @returns Generated ESM wrapper code
 *
 * @example
 * generateModuleSnippet('fs')
 * // Returns:
 * // const avoid_parse_require = require;
 * // const _M_ = avoid_parse_require("fs");
 * // export default _M_.default || _M_;
 * // export const readFile = _M_.readFile;
 * // export const writeFile = _M_.writeFile;
 * // ...
 */
export function generateModuleSnippet(moduleName: string): string {
  const exportNames = getModuleExportNames(moduleName);
  const exports = generateEsmExports(exportNames);

  // The avoid_parse_require pattern prevents bundler transformation
  return `const avoid_parse_require = require; const _M_ = avoid_parse_require("${moduleName}");\n${exports}`;
}

/**
 * Generate ESM wrapper snippet for a pre-bundled module
 *
 * Used for ESM packages that have been pre-bundled to CJS format.
 * The difference from generateModuleSnippet is that this uses a
 * file path instead of a module name.
 *
 * @param requirePath - Relative path for the require() call
 * @param modulePath - Absolute path for export introspection
 * @returns Generated ESM wrapper code
 *
 * @example
 * generatePreBundledSnippet('./node-fetch_index.cjs', '/abs/path/node-fetch_index.cjs')
 * // Returns wrapper that requires the bundled file and re-exports
 */
export function generatePreBundledSnippet(
  requirePath: string,
  modulePath: string
): string {
  const exportNames = getModuleExportNames(modulePath);
  const exports = generateEsmExports(exportNames);

  return `const avoid_parse_require = require; const _M_ = avoid_parse_require("${requirePath}");\n${exports}`;
}

/**
 * @deprecated Use generateModuleSnippet instead
 * Kept for backwards compatibility with existing code
 */
export const generateBuiltinSnippet = generateModuleSnippet;

/**
 * @deprecated Use generateModuleSnippet instead
 * The _exports parameter is no longer used as exports are detected automatically
 */
export const generateCjsWrapperSnippet = (
  moduleName: string,
  _exports: string[]
) => generateModuleSnippet(moduleName);

/**
 * Get module exports using require (for CJS modules)
 *
 * Public wrapper around getModuleExportNames for external use.
 *
 * @param moduleName - Name of the module to inspect
 * @returns Array of export names
 */
export function getModuleExports(moduleName: string): string[] {
  return getModuleExportNames(moduleName);
}
